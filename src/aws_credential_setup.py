#!/usr/bin/env python3
"""
AWS Credential Setup Helper
Automatically configures AWS credentials using bundled mshell and saml2aws
"""

import os
import sys
import subprocess
import logging
from pathlib import Path

logger = logging.getLogger(__name__)


def get_bundled_bin_path():
    """
    Get path to bundled binaries directory
    PyInstaller extracts to _MEIPASS temp directory which exists for entire runtime
    """
    if getattr(sys, 'frozen', False):
        # Running as PyInstaller executable - binaries in temp _MEIPASS/bin
        base_path = Path(sys._MEIPASS) / "bin"
    else:
        # Running as Python script - binaries are in ../bin
        base_path = Path(__file__).parent.parent / "bin"

    return base_path


def get_mshell_path():
    """Get path to bundled mshell binary"""
    bin_path = get_bundled_bin_path()
    mshell_path = bin_path / "mshell"

    if not mshell_path.exists():
        raise FileNotFoundError(f"mshell not found at: {mshell_path}")

    return str(mshell_path)


def get_saml2aws_path():
    """Get path to bundled saml2aws binary"""
    bin_path = get_bundled_bin_path()
    saml2aws_path = bin_path / "saml2aws"

    if not saml2aws_path.exists():
        raise FileNotFoundError(f"saml2aws not found at: {saml2aws_path}")

    return str(saml2aws_path)


def check_aws_config_exists():
    """Check if ~/.aws/config exists and has credential_process configured"""
    aws_config_path = Path.home() / ".aws" / "config"

    if not aws_config_path.exists():
        return False

    # Check if it has credential_process entries
    try:
        with open(aws_config_path, 'r') as f:
            content = f.read()
            return 'credential_process' in content
    except Exception as e:
        logger.warning(f"Error reading AWS config: {e}")
        return False


def create_aws_config():
    """
    Create minimal AWS config with credential_process pointing to bundled mshell
    """
    aws_dir = Path.home() / ".aws"
    aws_config_path = aws_dir / "config"

    # Create ~/.aws directory if it doesn't exist
    aws_dir.mkdir(parents=True, exist_ok=True)

    # Get bundled mshell path and bin directory
    mshell_path = get_mshell_path()
    bundled_bin = get_bundled_bin_path()

    # AWS config template with Skyscanner sandbox role
    # Use bash -c to set PATH before running mshell so it can find saml2aws
    config_content = f"""# AWS Configuration for Quality Evaluation Tool
# Auto-generated by quality_evaluation tool

[default]
region = eu-west-1
credential_process = bash -c 'PATH={bundled_bin}:$PATH {mshell_path} saml2aws --role arn:aws:iam::295180981731:role/SandboxAccessADFS --profile default'
"""

    # Write config
    logger.info(f"Creating AWS config at: {aws_config_path}")
    with open(aws_config_path, 'w') as f:
        f.write(config_content)

    logger.info("‚úÖ AWS config created successfully")


def pre_authenticate():
    """
    Pre-authenticate with AWS before boto3 tries to use credential_process
    This caches credentials so subsequent credential_process calls work
    """
    try:
        mshell_path = get_mshell_path()
        bundled_bin = get_bundled_bin_path()

        # Set up environment with bundled bin in PATH so mshell can find saml2aws
        env = os.environ.copy()
        env['PATH'] = f"{bundled_bin}:{env.get('PATH', '')}"

        # Remove stale kubeconfig lock file if it exists
        # mshell config update writes to ~/.kube/config and can fail if lock exists
        kube_lock_path = Path.home() / ".kube" / "config.lock"
        if kube_lock_path.exists():
            logger.info("üßπ Removing stale kubeconfig lock file...")
            kube_lock_path.unlink()

        # Run mshell config update first to ensure config is up-to-date
        logger.info("‚öôÔ∏è  Updating mshell configuration...")
        config_result = subprocess.run(
            [mshell_path, "config", "update"],
            capture_output=True,
            text=True,
            timeout=300,  # 5 minutes for user to complete SSO login
            env=env
        )

        if config_result.returncode != 0:
            logger.error(f"‚ùå mshell config update failed: {config_result.stderr}")
            return False

        logger.info("‚úÖ mshell config updated successfully")

        # Fix AWS config to use bundled mshell instead of system mshell
        # mshell config update writes "credential_process = mshell saml2aws..."
        # We need to replace it with the full path to bundled mshell
        logger.info("‚öôÔ∏è  Updating AWS config to use bundled mshell...")
        aws_config_path = Path.home() / ".aws" / "config"
        if aws_config_path.exists():
            import re
            with open(aws_config_path, 'r') as f:
                config_content = f.read()

            # Replace each credential_process line that uses mshell
            # Pattern: credential_process = mshell saml2aws <rest of line>
            # Replace with: credential_process = bash -c 'PATH=<bundled_bin>:$PATH <mshell_path> saml2aws <rest of line>'
            pattern = r'credential_process\s*=\s*mshell\s+saml2aws\s+(.+?)$'
            replacement = f'credential_process = bash -c \'PATH={bundled_bin}:$PATH {mshell_path} saml2aws \\1\''

            updated_content = re.sub(pattern, replacement, config_content, flags=re.MULTILINE)

            with open(aws_config_path, 'w') as f:
                f.write(updated_content)

            logger.info("‚úÖ AWS config updated to use bundled binaries")

        logger.info("üîê Authenticating with AWS...")

        # Run mshell saml2aws to cache credentials
        result = subprocess.run(
            [mshell_path, "saml2aws", "--role", "arn:aws:iam::295180981731:role/SandboxAccessADFS", "--profile", "default"],
            capture_output=True,
            text=True,
            timeout=300,  # 5 minutes for user to complete authentication
            env=env  # Pass environment with updated PATH
        )

        if result.returncode == 0:
            logger.info("‚úÖ AWS authentication successful")
            return True
        else:
            logger.error(f"‚ùå Authentication failed: {result.stderr}")
            return False

    except subprocess.TimeoutExpired:
        logger.error("‚ùå Authentication timeout - please complete SSO login within 5 minutes")
        return False
    except Exception as e:
        logger.error(f"‚ùå Authentication error: {e}")
        return False


def setup_credentials():
    """
    Main entry point: Setup AWS credentials for the tool

    This function:
    1. Always regenerates ~/.aws/config (because PyInstaller temp path changes each run)
    2. Pre-authenticates to cache credentials
    """
    logger.info("üîç Setting up AWS credential configuration...")

    # ALWAYS regenerate AWS config because PyInstaller's _MEIPASS path changes each run
    logger.info("‚öôÔ∏è  Generating AWS configuration with current binary paths...")
    try:
        create_aws_config()
        logger.info("‚úÖ AWS credential setup complete")
    except Exception as e:
        logger.error(f"‚ùå Failed to setup AWS credentials: {e}")
        raise

    # Pre-authenticate to cache credentials - MANDATORY
    logger.info("üîê Pre-authenticating with AWS...")
    if not pre_authenticate():
        logger.error("‚ùå Pre-authentication failed")
        logger.error("Please ensure you complete the SSO login in your browser")
        raise RuntimeError("AWS authentication required to run this tool")


def verify_binaries():
    """Verify bundled binaries are present and accessible"""
    try:
        mshell_path = get_mshell_path()
        saml2aws_path = get_saml2aws_path()

        logger.info(f"‚úÖ Found bundled mshell: {mshell_path}")
        logger.info(f"‚úÖ Found bundled saml2aws: {saml2aws_path}")

        return True

    except Exception as e:
        logger.error(f"‚ùå Binary verification failed: {e}")
        return False


if __name__ == "__main__":
    # Test the setup
    logging.basicConfig(level=logging.INFO)

    print("Testing AWS credential setup...")
    if verify_binaries():
        setup_credentials()
        print("\n‚úÖ Setup complete!")
    else:
        print("\n‚ùå Setup failed - binaries not found")
        sys.exit(1)
